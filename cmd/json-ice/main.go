package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/moznion/go-json-ice/internal"
	g "github.com/moznion/gowrtr/generator"
)

var (
	typeName = flag.String("type", "", "[mandatory] a type name")
	output   = flag.String("output", "", `[optional] output file name (default "srcdir/<type>_gen.go")`)
)

func main() {
	flag.Parse()

	if *typeName == "" {
		log.Fatal("[error] mandatory parameter `-type` is missing")
	}

	args := flag.Args()
	if len(args) <= 0 {
		args = []string{"."}
	}

	pkg, err := internal.ParsePackage(args)
	if err != nil {
		log.Fatal(fmt.Errorf("[error] failed to parse a package: %w", err))
	}

	astFiles, err := internal.ParseFiles(pkg.GoFiles)
	if err != nil {
		log.Fatal(fmt.Errorf("[error] failed to parse a file: %w", err))
	}

	rootStmt := g.NewRoot(
		g.NewComment(fmt.Sprintf(` Code generated by "json-ice %s"; DO NOT EDIT.`, strings.Join(os.Args[1:], " "))),
		g.NewNewline(),
		g.NewPackage(pkg.Name),
		g.NewNewline(),
	)

	for _, astFile := range astFiles {
		for _, decl := range astFile.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok {
				continue
			}

			for _, spec := range genDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}

				structName := typeSpec.Name.Name
				if *typeName != structName {
					continue
				}

				// TODO type alias support

				structType, ok := typeSpec.Type.(*ast.StructType)
				if !ok {
					continue
				}

				funcSignature := g.NewFuncSignature("MarshalJSON").ReturnTypes("[]byte", "error")
				funcStmt := g.NewFunc(
					g.NewFuncReceiver("s", "*"+structName),
					funcSignature,
					g.NewRawStatement("var err error"),
					g.NewRawStatement(`buff := bytes.NewBuffer([]byte("{"))`),
				)

				prependComma := false
				for _, field := range structType.Fields.List {
					fieldName := field.Names[0].Name
					fieldType := types.ExprString(field.Type)
					customTag := reflect.StructTag(field.Tag.Value[1 : len(field.Tag.Value)-1])

					jsonTagValues := strings.Split(customTag.Get("json"), ",")
					if len(jsonTagValues) <= 0 {
						// no json field
						continue
					}
					jsonPropertyName := jsonTagValues[0]

					isOmitEmpty := false
					if len(jsonTagValues) >= 2 {
						for _, v := range jsonTagValues[1:] {
							if v == "omitempty" {
								isOmitEmpty = true
								break
							}
						}
					}

					// TODO support pointer type

					nonEmptyValueCondition := ""
					serializeFuncInvocation := ""
					switch fieldType {
					case "bool":
						serializeFuncInvocation = fmt.Sprintf("serializer.SerializeBool(s.%s)", fieldName)
						nonEmptyValueCondition = fmt.Sprintf("s.%s", fieldName) // TODO pointer type support
					case "int", "int8", "int16", "int32", "int64":
						serializeFuncInvocation = fmt.Sprintf("serializer.SerializeInt(int64(s.%s))", fieldName)
						nonEmptyValueCondition = fmt.Sprintf("s.%s != 0", fieldName) // TODO pointer type support
					case "uint", "uint8", "uint16", "uint32", "uint64":
						serializeFuncInvocation = fmt.Sprintf("serializer.SerializeUint(uint64(s.%s))", fieldName)
						nonEmptyValueCondition = fmt.Sprintf("s.%s != 0", fieldName) // TODO pointer type support
					case "float32", "float64":
						serializeFuncInvocation = fmt.Sprintf("serializer.SerializeFloat(float64(s.%s))", fieldName)
						nonEmptyValueCondition = fmt.Sprintf("s.%s != 0", fieldName) // TODO pointer type support
					case "string":
						serializeFuncInvocation = fmt.Sprintf("serializer.SerializeString(s.%s)", fieldName)
						nonEmptyValueCondition = fmt.Sprintf(`s.%s != ""`, fieldName) // TODO pointer type support
					default:
						panic("TODO")
					}

					buffWriteStmts := []g.Statement{
						g.NewRawStatementf(
							`_, err = buff.WriteString("%s"+serializer.SerializePropertyName("%s")+":"+string(%s))`,
							(func() string {
								if prependComma {
									return ","
								}
								return ""
							})(),
							jsonPropertyName,
							serializeFuncInvocation,
						),
						g.NewIf("err != nil", g.NewReturnStatement("nil", "err")),
					}

					if isOmitEmpty {
						funcStmt = funcStmt.AddStatements(
							g.NewIf(nonEmptyValueCondition, buffWriteStmts...),
						)
					} else {
						funcStmt = funcStmt.AddStatements(
							buffWriteStmts...,
						)
					}

					prependComma = true
				}

				funcStmt = funcStmt.AddStatements(
					g.NewRawStatement(`_, err = buff.WriteString("}")`),
					g.NewIf("err != nil", g.NewReturnStatement("nil", "err")),
					g.NewReturnStatement("buff.Bytes(), nil"),
				)

				rootStmt = rootStmt.AddStatements(funcStmt)
			}
		}
	}

	code, err := rootStmt.Gofmt("-s").Goimports().Generate(0)
	if err != nil {
		log.Fatal(err)
	}

	err = ioutil.WriteFile(getFilenameToGenerate(args), []byte(code), 0644)
	if err != nil {
		log.Fatal(fmt.Errorf("[error] failed output generated code to a file: %w", err))
	}
}

func getFilenameToGenerate(args []string) string {
	if *output != "" {
		return *output
	}

	var dir string
	if len(args) == 1 && isDirectory(args[0]) {
		dir = args[0]
	} else {
		dir = filepath.Dir(args[0])
	}
	return fmt.Sprintf("%s/%s_gen.go", dir, strcase.ToSnake(*typeName))
}

func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}
