package main

import (
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/moznion/go-json-ice/internal"
	g "github.com/moznion/gowrtr/generator"
)

var (
	typeName      = flag.String("type", "", "[mandatory] a type name")
	output        = flag.String("output", "", `[optional] output file name (default "srcdir/<type>_gen.go")`)
	givenCapSize  = flag.Int64("cap-size", 0, `[optional] a cap-size of a byte slice buffer for marshaling; by default, it calculates this value automatically`)
	version       = flag.Bool("version", false, `show version information`)
	topLevelArray = flag.Bool("toplevel-array", false, `[optional] generate a marshaler for toplevel-array with given type by "--type" (e.g. "[]string")`)
)

type kind uint8

const (
	boolKind kind = iota
	numKind
	stringKind
	sliceKind
	mapKind
	nonPrimitiveKind
	noneKind
)

var kind2EmptyValue = map[kind]string{
	boolKind:   "false",
	numKind:    "0",
	stringKind: `""`,
}

type nillable uint8

const (
	nonNil nillable = iota
	nillablePointer
	nillableSliceOrMap
)

const defaultCapScore = 20 // XXX: not confident

func (n nillable) isNillable() bool {
	return n != nonNil
}

func main() {
	flag.Parse()

	if *version {
		internal.ShowVersion()
		os.Exit(0)
	}

	if *typeName == "" {
		log.Print("[error] mandatory parameter `-type` is missing")
		flag.Usage()
		os.Exit(1)
	}

	args := flag.Args()
	if len(args) <= 0 {
		args = []string{"."}
	}

	pkg, err := internal.ParsePackage(args)
	if err != nil {
		log.Fatal(fmt.Errorf("[error] failed to parse a package: %w", err))
	}

	astFiles, err := internal.ParseFiles(pkg.GoFiles)
	if err != nil {
		log.Fatal(fmt.Errorf("[error] failed to parse a file: %w", err))
	}

	rootStmt := g.NewRoot(
		g.NewComment(fmt.Sprintf(` Code generated by "json-ice %s"; DO NOT EDIT.`, strings.Join(os.Args[1:], " "))),
		g.NewNewline(),
		g.NewPackage(pkg.Name),
		g.NewNewline(),
	)

	fileBaseName := ""
	if *topLevelArray {
		sliceType := *typeName
		matched, err := matchSliceType(sliceType)
		if err != nil {
			log.Fatalf(`"--toplevel-array" given, but the type looks not be an array: %s`, sliceType)
		}
		subType := matched[1]

		appendSerializedSliceFuncInvocation, _, _, err := getSerializedValueFuncInvocationCode(sliceType, false)
		if err != nil {
			log.Fatal(err)
		}

		rootStmt = rootStmt.AddStatements(g.NewFunc(
			nil,
			g.NewFuncSignature(fmt.Sprintf("Marshal%sArrayAsJSON", strcase.ToCamel(subType))).
				Parameters(g.NewFuncParameter("sl", sliceType)).
				ReturnTypes("[]byte", "error"),
			g.NewRawStatementf("buff := make([]byte, 0, %d)", defaultCapScore),
			g.NewRawStatementf(appendSerializedSliceFuncInvocation, "sl"),
			g.NewReturnStatement("buff", "nil"),
		))
		fileBaseName = strcase.ToSnake(subType)+"_array"
	} else {
		for _, astFile := range astFiles {
			for _, decl := range astFile.Decls {
				genDecl, ok := decl.(*ast.GenDecl)
				if !ok {
					continue
				}

				for _, spec := range genDecl.Specs {
					typeSpec, ok := spec.(*ast.TypeSpec)
					if !ok {
						continue
					}

					structName := typeSpec.Name.Name
					if *typeName != structName {
						continue
					}

					structType, ok := typeSpec.Type.(*ast.StructType)
					if !ok {
						continue
					}

					funcName := fmt.Sprintf("Marshal%sAsJSON", structName)
					funcSignature := g.NewFuncSignature(funcName).
						Parameters(g.NewFuncParameter("s", "*"+structName)).
						ReturnTypes("[]byte", "error")
					funcStmt := g.NewFunc(
						nil,
						funcSignature,
					)

					stmts := make([]g.Statement, 0)

					capScoreSum := int64(2) // len of envelope `{}`
					for _, field := range structType.Fields.List {
						fieldName := field.Names[0].Name
						fieldType := types.ExprString(field.Type)
						customTag := reflect.StructTag(field.Tag.Value[1 : len(field.Tag.Value)-1])

						jsonTagValues := strings.Split(customTag.Get("json"), ",")
						if len(jsonTagValues) <= 0 {
							// no json field
							continue
						}
						capScoreSum += defaultCapScore
						jsonPropertyName := jsonTagValues[0]

						isOmitEmpty := false
						if len(jsonTagValues) >= 2 {
							for _, v := range jsonTagValues[1:] {
								if v == "omitempty" {
									isOmitEmpty = true
									break
								}
							}
						}

						appendSerializedItemFuncInvocation, nillable, fieldKind, err := getSerializedValueFuncInvocationCode(fieldType, false)
						if err != nil {
							log.Fatal(fmt.Errorf("[error] failed to generate code: %w", err))
						}

						buffWriteStmts := []g.Statement{
							g.NewRawStatementf(`buff = append(buff, "\"%s\":"...)`, jsonPropertyName),
							g.NewRawStatementf(appendSerializedItemFuncInvocation, fmt.Sprintf("%ss.%s", getDereferenceSigil(fieldKind, nillable == nillablePointer), fieldName)),
							g.NewRawStatement(`buff = append(buff, ',')`),
						}

						nonEmptyValueCondition := ""
						if kind2EmptyValue[fieldKind] != "" {
							nonEmptyValueCondition = fmt.Sprintf("s.%s != %s", fieldName, kind2EmptyValue[fieldKind])
						}
						isNilCondition := ""
						switch nillable {
						case nillablePointer:
							isNilCondition = fmt.Sprintf("s.%s == nil", fieldName)
							if kind2EmptyValue[fieldKind] != "" {
								nonEmptyValueCondition = fmt.Sprintf("s.%s != nil && *s.%s != %s", fieldName, fieldName, kind2EmptyValue[fieldKind])
							} else {
								nonEmptyValueCondition = fmt.Sprintf("s.%s != nil", fieldName)
							}
						case nillableSliceOrMap:
							capScoreSum += 20 // XXX add extra score if the field is slice or map
							isNilCondition = fmt.Sprintf("s.%s == nil", fieldName)
							nonEmptyValueCondition = fmt.Sprintf("s.%s != nil && len(s.%s) > 0", fieldName, fieldName)
						}

						if isOmitEmpty {
							if nonEmptyValueCondition != "" {
								stmts = append(stmts, g.NewIf(nonEmptyValueCondition, buffWriteStmts...))
							} else {
								stmts = append(stmts, buffWriteStmts...)
							}
						} else {
							stmt := buffWriteStmts
							if isNilCondition != "" {
								stmt = []g.Statement{g.NewIf(
									isNilCondition,
									g.NewRawStatementf(
										`buff = append(buff, "\"%s\":null,"...)`,
										jsonPropertyName,
									),
								).Else(g.NewElse(buffWriteStmts...))}
							}
							stmts = append(stmts, stmt...)
						}
					}

					stmts = append(
						stmts,
						// dealing with trailing comma
						g.NewIf(`buff[len(buff)-1] == ','`, g.NewRawStatement("buff[len(buff)-1] = '}'")).
							Else(g.NewElse(g.NewRawStatement("buff = append(buff, '}')"))),

						g.NewReturnStatement("buff, nil"),
					)

					rootStmt = rootStmt.AddStatements(
						funcStmt.AddStatements(
							g.NewRawStatementf("buff := make([]byte, 1, %d)", func() int64 {
								if *givenCapSize > 0 {
									return *givenCapSize
								}
								return int64(float64(capScoreSum) * 1.3)
							}()),
							g.NewRawStatement("buff[0] = '{'"),
						).AddStatements(
							stmts...,
						),
					)
				}
			}
		}
		fileBaseName = strcase.ToSnake(*typeName)
	}

	code, err := rootStmt.
		Gofmt("-s").
		Goimports().
		Generate(0)
	if err != nil {
		log.Fatal(err)
	}

	err = ioutil.WriteFile(getFilenameToGenerate(args, fileBaseName), []byte(code), 0644)
	if err != nil {
		log.Fatal(fmt.Errorf("[error] failed output generated code to a file: %w", err))
	}
}

func getFilenameToGenerate(args []string, typeName string) string {
	if *output != "" {
		return *output
	}

	var dir string
	if len(args) == 1 && isDirectory(args[0]) {
		dir = args[0]
	} else {
		dir = filepath.Dir(args[0])
	}
	return fmt.Sprintf("%s/%s_gen.go", dir, strcase.ToSnake(typeName))
}

func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}

func getDereferenceSigil(fieldKind kind, isPointer bool) string {
	if fieldKind == nonPrimitiveKind {
		return ""
	}

	if isPointer {
		return "*"
	}
	return ""
}

func getSerializedValueFuncInvocationCode(typ string, isMapKey bool) (string, nillable, kind, error) {
	nillable := nonNil
	if strings.HasPrefix(typ, "*") {
		typ = strings.Replace(typ, "*", "", 1)
		nillable = nillablePointer
	}

	switch typ {
	case "bool":
		return "buff = serializer.AppendSerializedBool(buff, %s)", nillable, boolKind, nil
	case "int", "int8", "int16", "int32", "int64":
		return "buff = serializer.AppendSerializedInt(buff, int64(%s))", nillable, numKind, nil
	case "uint", "uint8", "uint16", "uint32", "uint64":
		return "buff = serializer.AppendSerializedUint(buff, uint64(%s))", nillable, numKind, nil
	case "float32", "float64":
		return "buff = serializer.AppendSerializedFloat(buff, float64(%s))", nillable, numKind, nil
	case "string":
		return "buff = serializer.AppendSerializedString(buff, %s)", nillable, stringKind, nil
	default:
		if isMapKey {
			return "", nonNil, noneKind, errors.New("prohibited using non-primitive type value for map key")
		}

		// slice type
		if matched, err := matchSliceType(typ); err == nil {
			valueType := matched[1]

			appendSerializedValueFuncInvocation, nillable, fieldKind, err := getSerializedValueFuncInvocationCode(valueType, false)
			if err != nil {
				return "", nonNil, noneKind, err
			}

			code, err := g.NewRoot(
				g.NewRawStatement("buff = append(buff, '[')"),
				g.NewFor(
					"_, v := range %s",
					func() g.Statement {
						if nillable.isNillable() {
							return g.NewIf(
								"v == nil",
								g.NewRawStatement(`buff = append(buff, "null"...)`),
							).Else(g.NewElse(
								g.NewRawStatementf(appendSerializedValueFuncInvocation, getDereferenceSigil(fieldKind, nillable == nillablePointer)+"v"),
							))
						}
						return g.NewRawStatementf(appendSerializedValueFuncInvocation, getDereferenceSigil(fieldKind, nillable == nillablePointer)+"v")
					}(),
					g.NewRawStatement("buff = append(buff, ',')"),
				),
				// dealing with trailing comma
				g.NewIf(`buff[len(buff)-1] == ','`, g.NewRawStatement("buff[len(buff)-1] = ']'")).
					Else(g.NewElse(g.NewRawStatement("buff = append(buff, ']')"))),
			).Generate(0)
			if err != nil {
				return "", nonNil, noneKind, err
			}
			return code, nillableSliceOrMap, sliceKind, nil
		}

		// map type
		if matched := regexp.MustCompile("^map\\[([^]]+)](.+)").FindStringSubmatch(typ); len(matched) >= 3 {
			keyType := matched[1]
			valueType := matched[2]
			appendSerializedMapKeyTypeInvocation, keyNillable, keyKind, err := getSerializedValueFuncInvocationCode(keyType, true)
			if err != nil {
				return "", nonNil, noneKind, err
			}
			appendSerializedMapValueTypeInvocation, valueNillable, valueKind, err := getSerializedValueFuncInvocationCode(valueType, false)
			if err != nil {
				return "", nonNil, noneKind, err
			}

			code, err := g.NewRoot(
				g.NewRawStatement("buff = append(buff, '{')"),
				g.NewFor(
					"mapKey, mapValue := range %s",
					func() []g.Statement {
						if keyType == "string" {
							// key has been already quoted
							return []g.Statement{
								g.NewRawStatementf(appendSerializedMapKeyTypeInvocation, getDereferenceSigil(keyKind, keyNillable == nillablePointer)+"mapKey"),
							}
						}

						// quote the key manually
						return []g.Statement{
							g.NewRawStatement(`buff = append(buff, '"')`),
							g.NewRawStatementf(appendSerializedMapKeyTypeInvocation, getDereferenceSigil(keyKind, keyNillable == nillablePointer)+"mapKey"),
							g.NewRawStatement(`buff = append(buff, '"')`),
						}
					}()...,
				).AddStatements(
					g.NewRawStatement("buff = append(buff, ':')"),
					func() g.Statement {
						if valueNillable.isNillable() {
							return g.NewIf(
								"mapValue == nil",
								g.NewRawStatement(`buff = append(buff, "null"...)`),
							).Else(g.NewElse(
								g.NewRawStatementf(appendSerializedMapValueTypeInvocation, getDereferenceSigil(valueKind, valueNillable == nillablePointer)+"mapValue"),
							))
						}
						return g.NewRawStatementf(appendSerializedMapValueTypeInvocation, getDereferenceSigil(valueKind, valueNillable == nillablePointer)+"mapValue")
					}(),
				).AddStatements(
					g.NewRawStatement("buff = append(buff, ',')"),
				),
				// dealing with trailing comma
				g.NewIf(`buff[len(buff)-1] == ','`, g.NewRawStatement("buff[len(buff)-1] = '}'")).
					Else(g.NewElse(g.NewRawStatement("buff = append(buff, '}')"))),
			).Generate(0)
			if err != nil {
				return "", nonNil, noneKind, err
			}
			return code, nillableSliceOrMap, mapKind, nil
		}

		code, err := g.NewIf(
			"marshaled, err := %s.MarshalJSON(); err != nil",
			g.NewReturnStatement("nil", "err"),
		).Else(g.NewElse(
			g.NewRawStatement("buff = append(buff, marshaled...)"),
		)).Generate(0)
		if err != nil {
			return "", nonNil, noneKind, err
		}
		return code, nillable, nonPrimitiveKind, nil
	}
}

func matchSliceType(typ string) ([]string, error) {
	matched := regexp.MustCompile("^\\[](.+)").FindStringSubmatch(typ)
	if len(matched) < 2 {
		return nil, errors.New("doesn't match with slice type")
	}
	return matched, nil
}
