package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/moznion/go-json-ice/internal"
	g "github.com/moznion/gowrtr/generator"
)

var (
	typeName = flag.String("type", "", "[mandatory] a type name")
	output   = flag.String("output", "", `[optional] output file name (default "srcdir/<type>_gen.go")`)
)

var mapFieldTypeRe = regexp.MustCompile("^map\\[([^]]+)](.+)")

func main() {
	flag.Parse()

	if *typeName == "" {
		log.Fatal("[error] mandatory parameter `-type` is missing")
	}

	args := flag.Args()
	if len(args) <= 0 {
		args = []string{"."}
	}

	pkg, err := internal.ParsePackage(args)
	if err != nil {
		log.Fatal(fmt.Errorf("[error] failed to parse a package: %w", err))
	}

	astFiles, err := internal.ParseFiles(pkg.GoFiles)
	if err != nil {
		log.Fatal(fmt.Errorf("[error] failed to parse a file: %w", err))
	}

	rootStmt := g.NewRoot(
		g.NewComment(fmt.Sprintf(` Code generated by "json-ice %s"; DO NOT EDIT.`, strings.Join(os.Args[1:], " "))),
		g.NewNewline(),
		g.NewPackage(pkg.Name),
		g.NewNewline(),
	)

	for _, astFile := range astFiles {
		for _, decl := range astFile.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok {
				continue
			}

			for _, spec := range genDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}

				structName := typeSpec.Name.Name
				if *typeName != structName {
					continue
				}

				// TODO type alias support

				structType, ok := typeSpec.Type.(*ast.StructType)
				if !ok {
					continue
				}

				funcName := fmt.Sprintf("Marshal%sAsJSON", structName)
				funcSignature := g.NewFuncSignature(funcName).
					Parameters(g.NewFuncParameter("s", "*"+structName)).
					ReturnTypes("[]byte", "error")
				funcStmt := g.NewFunc(
					nil,
					funcSignature,
					g.NewRawStatement(`buff := make([]byte, 1, 500)`), // TODO calc cap size
					g.NewRawStatement(`buff[0] = '{'`),
				)

				for _, field := range structType.Fields.List {
					fieldName := field.Names[0].Name
					fieldType := types.ExprString(field.Type)
					customTag := reflect.StructTag(field.Tag.Value[1 : len(field.Tag.Value)-1])

					jsonTagValues := strings.Split(customTag.Get("json"), ",")
					if len(jsonTagValues) <= 0 {
						// no json field
						continue
					}
					jsonPropertyName := jsonTagValues[0]

					isOmitEmpty := false
					if len(jsonTagValues) >= 2 {
						for _, v := range jsonTagValues[1:] {
							if v == "omitempty" {
								isOmitEmpty = true
								break
							}
						}
					}

					isSlice := false
					if strings.HasPrefix(fieldType, "[]") {
						fieldType = strings.Replace(fieldType, "[]", "", 1)
						isSlice = true
					}

					isPointer := false
					if strings.HasPrefix(fieldType, "*") {
						fieldType = strings.Replace(fieldType, "*", "", 1)
						isPointer = true
					}

					appendSerializedItemFuncInvocation, emptyValue := getTypeToSerializerAndEmptyValue(fieldType)
					appendSerializedMapKeyTypeInvocation := ""
					appendSerializedMapValueTypeInvocation := ""
					if matched := mapFieldTypeRe.FindStringSubmatch(fieldType); len(matched) >= 3 {
						appendSerializedMapKeyTypeInvocation, _ = getTypeToSerializerAndEmptyValue(matched[1])
						appendSerializedMapValueTypeInvocation, _ = getTypeToSerializerAndEmptyValue(matched[2])
					}

					buffWriteStmts := []g.Statement{
						g.NewRawStatementf(
							`buff = append(buff, "\"%s\":"...)`,
							jsonPropertyName,
						),
					}
					buffWriteStmts = append(buffWriteStmts,
						func() []g.Statement {
							if isSlice {
								return []g.Statement{
									g.NewRawStatement("buff = append(buff, '[')"),
									g.NewFor(
										fmt.Sprintf("_, v := range s.%s", fieldName),
										func() []g.Statement {
											if appendSerializedMapKeyTypeInvocation != "" && appendSerializedMapValueTypeInvocation != "" {
												return []g.Statement{
													g.NewRawStatement("buff = append(buff, '{')"),
													g.NewFor(
														"mapKey, mapValue := range v",
														g.NewRawStatementf("buff = %s", fmt.Sprintf(appendSerializedMapKeyTypeInvocation, "mapKey")), // TODO quote
														g.NewRawStatement("buff = append(buff, ':')"),
														g.NewRawStatementf("buff = %s", fmt.Sprintf(appendSerializedMapValueTypeInvocation, "mapValue")),
														g.NewRawStatement("buff = append(buff, ',')"),
													),
													// dealing with trailing comma
													g.NewIf(`buff[len(buff)-1] == ','`, g.NewRawStatement("buff[len(buff)-1] = '}'")).
														Else(g.NewElse(g.NewRawStatement("buff = append(buff, '}')"))),
													g.NewRawStatement("buff = append(buff, ',')"),
												}
											}
											return []g.Statement{
												g.NewRawStatementf("buff = %s", fmt.Sprintf(appendSerializedItemFuncInvocation, getDereferenceSigil(isPointer)+"v")),
												g.NewRawStatement("buff = append(buff, ',')"),
											}
										}()...,

									),
									// dealing with trailing comma
									g.NewIf(`buff[len(buff)-1] == ','`, g.NewRawStatement("buff[len(buff)-1] = ']'")).
										Else(g.NewElse(g.NewRawStatement("buff = append(buff, ']')"))),
								}
							}

							if appendSerializedMapKeyTypeInvocation != "" && appendSerializedMapValueTypeInvocation != "" {
								return []g.Statement{
									g.NewRawStatement("buff = append(buff, '{')"),
									g.NewFor(
										fmt.Sprintf("mapKey, mapValue := range s.%s", fieldName),
										g.NewRawStatementf("buff = %s", fmt.Sprintf(appendSerializedMapKeyTypeInvocation, "mapKey")), // TODO quote
										g.NewRawStatement("buff = append(buff, ':')"),
										g.NewRawStatementf("buff = %s", fmt.Sprintf(appendSerializedMapValueTypeInvocation, "mapValue")),
										g.NewRawStatement("buff = append(buff, ',')"),
									),
									// dealing with trailing comma
									g.NewIf(`buff[len(buff)-1] == ','`, g.NewRawStatement("buff[len(buff)-1] = '}'")).
										Else(g.NewElse(g.NewRawStatement("buff = append(buff, '}')"))),
								}
							}

							return []g.Statement{g.NewRawStatementf("buff = %s", fmt.Sprintf(appendSerializedItemFuncInvocation, fmt.Sprintf("%ss.%s", getDereferenceSigil(isPointer), fieldName)))}
						}()...,
					)
					buffWriteStmts = append(buffWriteStmts, g.NewRawStatement(`buff = append(buff, ',')`))

					nonEmptyValueCondition := fmt.Sprintf("s.%s != %s", fieldName, emptyValue)
					isNilCondition := ""
					if isSlice {
						isNilCondition = fmt.Sprintf("s.%s == nil", fieldName)
						nonEmptyValueCondition = fmt.Sprintf("s.%s != nil && len(s.%s) > 0", fieldName, fieldName)
					} else if isPointer {
						isNilCondition = fmt.Sprintf("s.%s == nil", fieldName)
						nonEmptyValueCondition = fmt.Sprintf("s.%s != nil && *s.%s != %s", fieldName, fieldName, emptyValue)
					}

					if isOmitEmpty {
						funcStmt = funcStmt.AddStatements(g.NewIf(nonEmptyValueCondition, buffWriteStmts...))
					} else {
						stmt := buffWriteStmts
						if isNilCondition != "" {
							stmt = []g.Statement{g.NewIf(
								isNilCondition,
								g.NewRawStatementf(
									`buff = append(buff, "\"%s\":null,"...)`,
									jsonPropertyName,
								),
							).Else(g.NewElse(buffWriteStmts...))}
						}
						funcStmt = funcStmt.AddStatements(stmt...)
					}
				}

				funcStmt = funcStmt.AddStatements(
					// dealing with trailing comma
					g.NewIf(`buff[len(buff)-1] == ','`, g.NewRawStatement("buff[len(buff)-1] = '}'")).
						Else(g.NewElse(g.NewRawStatement("buff = append(buff, '}')"))),

					g.NewReturnStatement("buff, nil"),
				)

				rootStmt = rootStmt.AddStatements(funcStmt)
			}
		}
	}

	code, err := rootStmt.Gofmt("-s").Goimports().Generate(0)
	if err != nil {
		log.Fatal(err)
	}

	err = ioutil.WriteFile(getFilenameToGenerate(args), []byte(code), 0644)
	if err != nil {
		log.Fatal(fmt.Errorf("[error] failed output generated code to a file: %w", err))
	}
}

func getFilenameToGenerate(args []string) string {
	if *output != "" {
		return *output
	}

	var dir string
	if len(args) == 1 && isDirectory(args[0]) {
		dir = args[0]
	} else {
		dir = filepath.Dir(args[0])
	}
	return fmt.Sprintf("%s/%s_gen.go", dir, strcase.ToSnake(*typeName))
}

func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}

func getDereferenceSigil(isPointer bool) string {
	if isPointer {
		return "*"
	}
	return ""
}

func getTypeToSerializerAndEmptyValue(typ string) (string, string) {
	switch typ {
	case "bool":
		return "serializer.AppendSerializedBool(buff, %s)", "false"
	case "int", "int8", "int16", "int32", "int64":
		return "serializer.AppendSerializedInt(buff, int64(%s))", "0"
	case "uint", "uint8", "uint16", "uint32", "uint64":
		return "serializer.AppendSerializedUint(buff, uint64(%s))", "0"
	case "float32", "float64":
		return "serializer.AppendSerializedFloat(buff, float64(%s))", "0"
	case "string":
		return "serializer.AppendSerializedString(buff, %s)", `""`
	default:
		return "TODO", "TODO"
		//panic("TODO")
	}
}
