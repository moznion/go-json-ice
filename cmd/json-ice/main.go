package main

import (
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"regexp"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/moznion/go-json-ice/internal"
	g "github.com/moznion/gowrtr/generator"
)

var (
	typeName = flag.String("type", "", "[mandatory] a type name")
	output   = flag.String("output", "", `[optional] output file name (default "srcdir/<type>_gen.go")`)
)

type kind uint8

const (
	boolKind kind = iota
	numKind
	stringKind
	sliceKind
	mapKind
	noneKind
)

var kind2EmptyValue = map[kind]string{
	boolKind:   "false",
	numKind:    "0",
	stringKind: `""`,
}

type nillable uint8

const (
	nonNil nillable = iota
	nillablePointer
	nillableSliceOrMap
)

const defaultCapScore = 20 // XXX: not confident

func (n nillable) isNillable() bool {
	return n != nonNil
}

func main() {
	flag.Parse()

	if *typeName == "" {
		log.Fatal("[error] mandatory parameter `-type` is missing")
	}

	args := flag.Args()
	if len(args) <= 0 {
		args = []string{"."}
	}

	pkg, err := internal.ParsePackage(args)
	if err != nil {
		log.Fatal(fmt.Errorf("[error] failed to parse a package: %w", err))
	}

	astFiles, err := internal.ParseFiles(pkg.GoFiles)
	if err != nil {
		log.Fatal(fmt.Errorf("[error] failed to parse a file: %w", err))
	}

	rootStmt := g.NewRoot(
		g.NewComment(fmt.Sprintf(` Code generated by "json-ice %s"; DO NOT EDIT.`, strings.Join(os.Args[1:], " "))),
		g.NewNewline(),
		g.NewPackage(pkg.Name),
		g.NewNewline(),
	)

	for _, astFile := range astFiles {
		for _, decl := range astFile.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok {
				continue
			}

			for _, spec := range genDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}

				structName := typeSpec.Name.Name
				if *typeName != structName {
					continue
				}

				// TODO type alias support

				structType, ok := typeSpec.Type.(*ast.StructType)
				if !ok {
					continue
				}

				funcName := fmt.Sprintf("Marshal%sAsJSON", structName)
				funcSignature := g.NewFuncSignature(funcName).
					Parameters(g.NewFuncParameter("s", "*"+structName)).
					ReturnTypes("[]byte", "error")
				funcStmt := g.NewFunc(
					nil,
					funcSignature,
				)

				stmts := make([]g.Statement, 0)

				capScoreSum := int64(2) // len of envelope `{}`
				for _, field := range structType.Fields.List {
					fieldName := field.Names[0].Name
					fieldType := types.ExprString(field.Type)
					customTag := reflect.StructTag(field.Tag.Value[1 : len(field.Tag.Value)-1])

					jsonTagValues := strings.Split(customTag.Get("json"), ",")
					if len(jsonTagValues) <= 0 {
						// no json field
						continue
					}
					capScoreSum += defaultCapScore
					jsonPropertyName := jsonTagValues[0]

					isOmitEmpty := false
					if len(jsonTagValues) >= 2 {
						for _, v := range jsonTagValues[1:] {
							if v == "omitempty" {
								isOmitEmpty = true
								break
							}
						}
					}

					appendSerializedItemFuncInvocation, nillable, fieldKind, err := getSerializedValueFuncInvocationCode(fieldType, false)
					if err != nil {
						log.Fatal(fmt.Errorf("[error] failed to generate code: %w", err))
					}

					buffWriteStmts := []g.Statement{
						g.NewRawStatementf(`buff = append(buff, "\"%s\":"...)`, jsonPropertyName),
						g.NewRawStatementf(appendSerializedItemFuncInvocation, fmt.Sprintf("%ss.%s", getDereferenceSigil(nillable == nillablePointer), fieldName)),
						g.NewRawStatement(`buff = append(buff, ',')`),
					}

					nonEmptyValueCondition := fmt.Sprintf("s.%s != %s", fieldName, kind2EmptyValue[fieldKind])
					isNilCondition := ""
					switch nillable {
					case nillablePointer:
						isNilCondition = fmt.Sprintf("s.%s == nil", fieldName)
						nonEmptyValueCondition = fmt.Sprintf("s.%s != nil && *s.%s != %s", fieldName, fieldName, kind2EmptyValue[fieldKind])
					case nillableSliceOrMap:
						capScoreSum += 20 // XXX add extra score if the field is slice or map
						isNilCondition = fmt.Sprintf("s.%s == nil", fieldName)
						nonEmptyValueCondition = fmt.Sprintf("s.%s != nil && len(s.%s) > 0", fieldName, fieldName)
					}

					if isOmitEmpty {
						stmts = append(stmts, g.NewIf(nonEmptyValueCondition, buffWriteStmts...))
					} else {
						stmt := buffWriteStmts
						if isNilCondition != "" {
							stmt = []g.Statement{g.NewIf(
								isNilCondition,
								g.NewRawStatementf(
									`buff = append(buff, "\"%s\":null,"...)`,
									jsonPropertyName,
								),
							).Else(g.NewElse(buffWriteStmts...))}
						}
						stmts = append(stmts, stmt...)
					}
				}

				stmts = append(
					stmts,
					// dealing with trailing comma
					g.NewIf(`buff[len(buff)-1] == ','`, g.NewRawStatement("buff[len(buff)-1] = '}'")).
						Else(g.NewElse(g.NewRawStatement("buff = append(buff, '}')"))),

					g.NewReturnStatement("buff, nil"),
				)

				rootStmt = rootStmt.AddStatements(
					funcStmt.AddStatements(
						g.NewRawStatementf("buff := make([]byte, 1, %d)", int64(float64(capScoreSum) * 1.3)),
						g.NewRawStatement("buff[0] = '{'"),
					).AddStatements(
						stmts...,
					),
				)
			}
		}
	}

	code, err := rootStmt.Gofmt("-s").Goimports().Generate(0)
	if err != nil {
		log.Fatal(err)
	}

	err = ioutil.WriteFile(getFilenameToGenerate(args), []byte(code), 0644)
	if err != nil {
		log.Fatal(fmt.Errorf("[error] failed output generated code to a file: %w", err))
	}
}

func getFilenameToGenerate(args []string) string {
	if *output != "" {
		return *output
	}

	var dir string
	if len(args) == 1 && isDirectory(args[0]) {
		dir = args[0]
	} else {
		dir = filepath.Dir(args[0])
	}
	return fmt.Sprintf("%s/%s_gen.go", dir, strcase.ToSnake(*typeName))
}

func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}

func getDereferenceSigil(isPointer bool) string {
	if isPointer {
		return "*"
	}
	return ""
}

func getSerializedValueFuncInvocationCode(typ string, isMapKey bool) (string, nillable, kind, error) {
	nillable := nonNil
	if strings.HasPrefix(typ, "*") {
		typ = strings.Replace(typ, "*", "", 1)
		nillable = nillablePointer
	}

	switch typ {
	case "bool":
		code, err := g.NewIf(
			"%s",
			g.NewRawStatement(`buff = append(buff, "true"...)`),
		).Else(g.NewElse(
			g.NewRawStatement(`buff = append(buff, "false"...)`),
		)).Generate(0)
		if err != nil {
			return "", nonNil, noneKind, err
		}
		return code, nillable, boolKind, nil
	case "int", "int8", "int16", "int32", "int64":
		return "buff = strconv.AppendInt(buff, int64(%s), 10)", nillable, numKind, nil
	case "uint", "uint8", "uint16", "uint32", "uint64":
		return "buff = strconv.AppendUint(buff, uint64(%s), 10)", nillable, numKind, nil
	case "float32", "float64":
		return "buff = strconv.AppendFloat(buff, float64(%s), 'e', -1, 64)", nillable, numKind, nil
	case "string":
		return "buff = strconv.AppendQuote(buff, %s)", nillable, stringKind, nil
	default:
		if isMapKey {
			return "", nonNil, noneKind, errors.New("prohibited using non-primitive type value for map key")
		}

		// slice type
		if matched := regexp.MustCompile("^\\[](.+)").FindStringSubmatch(typ); len(matched) >= 2 {
			valueType := matched[1]

			appendSerializedValueFuncInvocation, nillable, _, err := getSerializedValueFuncInvocationCode(valueType, false)
			if err != nil {
				return "", nonNil, noneKind, err
			}

			code, err := g.NewRoot(
				g.NewRawStatement("buff = append(buff, '[')"),
				g.NewFor(
					"_, v := range %s",
					func() g.Statement {
						if nillable.isNillable() {
							return g.NewIf(
								"v == nil",
								g.NewRawStatement(`buff = append(buff, "null"...)`),
							).Else(g.NewElse(
								g.NewRawStatementf(appendSerializedValueFuncInvocation, getDereferenceSigil(nillable == nillablePointer)+"v"),
							))
						}
						return g.NewRawStatementf(appendSerializedValueFuncInvocation, getDereferenceSigil(nillable == nillablePointer)+"v")
					}(),
					g.NewRawStatement("buff = append(buff, ',')"),
				),
				// dealing with trailing comma
				g.NewIf(`buff[len(buff)-1] == ','`, g.NewRawStatement("buff[len(buff)-1] = ']'")).
					Else(g.NewElse(g.NewRawStatement("buff = append(buff, ']')"))),
			).Generate(0)
			if err != nil {
				return "", nonNil, noneKind, err
			}
			return code, nillableSliceOrMap, sliceKind, nil
		}

		// map type
		if matched := regexp.MustCompile("^map\\[([^]]+)](.+)").FindStringSubmatch(typ); len(matched) >= 3 {
			keyType := matched[1]
			valueType := matched[2]
			appendSerializedMapKeyTypeInvocation, keyNillable, _, err := getSerializedValueFuncInvocationCode(keyType, true)
			if err != nil {
				return "", nonNil, noneKind, err
			}
			appendSerializedMapValueTypeInvocation, valueNillable, _, err := getSerializedValueFuncInvocationCode(valueType, false)
			if err != nil {
				return "", nonNil, noneKind, err
			}

			code, err := g.NewRoot(
				g.NewRawStatement("buff = append(buff, '{')"),
				g.NewFor(
					"mapKey, mapValue := range %s",
					func() []g.Statement {
						if keyType == "string" {
							// key has been already quoted
							return []g.Statement{
								g.NewRawStatementf(appendSerializedMapKeyTypeInvocation, getDereferenceSigil(keyNillable == nillablePointer)+"mapKey"),
							}
						}

						// quote the key manually
						return []g.Statement{
							g.NewRawStatement(`buff = append(buff, '"')`),
							g.NewRawStatementf(appendSerializedMapKeyTypeInvocation, getDereferenceSigil(keyNillable == nillablePointer)+"mapKey"),
							g.NewRawStatement(`buff = append(buff, '"')`),
						}
					}()...,
				).AddStatements(
					g.NewRawStatement("buff = append(buff, ':')"),
					func() g.Statement {
						if valueNillable.isNillable() {
							return g.NewIf(
								"mapValue == nil",
								g.NewRawStatement(`buff = append(buff, "null"...)`),
							).Else(g.NewElse(
								g.NewRawStatementf(appendSerializedMapValueTypeInvocation, getDereferenceSigil(valueNillable == nillablePointer)+"mapValue"),
							))
						}
						return g.NewRawStatementf(appendSerializedMapValueTypeInvocation, getDereferenceSigil(valueNillable == nillablePointer)+"mapValue")
					}(),
				).AddStatements(
					g.NewRawStatement("buff = append(buff, ',')"),
				),
				// dealing with trailing comma
				g.NewIf(`buff[len(buff)-1] == ','`, g.NewRawStatement("buff[len(buff)-1] = '}'")).
					Else(g.NewElse(g.NewRawStatement("buff = append(buff, '}')"))),
			).Generate(0)
			if err != nil {
				return "", nonNil, noneKind, err
			}
			return code, nillableSliceOrMap, mapKind, nil
		}

		panic("TODO")
	}
}
