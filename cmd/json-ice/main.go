package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/moznion/go-json-ice/internal"
	g "github.com/moznion/gowrtr/generator"
)

var (
	typeName = flag.String("type", "", "[mandatory] a type name")
	output   = flag.String("output", "", `[optional] output file name (default "srcdir/<type>_gen.go")`)
)

func main() {
	flag.Parse()

	if *typeName == "" {
		log.Fatal("[error] mandatory parameter `-type` is missing")
	}

	args := flag.Args()
	if len(args) <= 0 {
		args = []string{"."}
	}

	pkg, err := internal.ParsePackage(args)
	if err != nil {
		log.Fatal(fmt.Errorf("[error] failed to parse a package: %w", err))
	}

	astFiles, err := internal.ParseFiles(pkg.GoFiles)
	if err != nil {
		log.Fatal(fmt.Errorf("[error] failed to parse a file: %w", err))
	}

	rootStmt := g.NewRoot(
		g.NewComment(fmt.Sprintf(` Code generated by "json-ice %s"; DO NOT EDIT.`, strings.Join(os.Args[1:], " "))),
		g.NewNewline(),
		g.NewPackage(pkg.Name),
		g.NewNewline(),
	)

	for _, astFile := range astFiles {
		for _, decl := range astFile.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok {
				continue
			}

			for _, spec := range genDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}

				structName := typeSpec.Name.Name
				if *typeName != structName {
					continue
				}

				// TODO type alias support

				structType, ok := typeSpec.Type.(*ast.StructType)
				if !ok {
					continue
				}

				funcSignature := g.NewFuncSignature("MarshalJSON").ReturnTypes("[]byte", "error")
				funcStmt := g.NewFunc(
					g.NewFuncReceiver("s", "*"+structName),
					funcSignature,
					g.NewRawStatement("var err error"),
					g.NewRawStatement(`buff := bytes.NewBuffer([]byte("{"))`),
				)

				for _, field := range structType.Fields.List {
					fieldName := field.Names[0].Name
					fieldType := types.ExprString(field.Type)
					customTag := reflect.StructTag(field.Tag.Value[1 : len(field.Tag.Value)-1])

					jsonTagValues := strings.Split(customTag.Get("json"), ",")
					if len(jsonTagValues) <= 0 {
						// no json field
						continue
					}
					jsonPropertyName := jsonTagValues[0]

					isOmitEmpty := false
					if len(jsonTagValues) >= 2 {
						for _, v := range jsonTagValues[1:] {
							if v == "omitempty" {
								isOmitEmpty = true
								break
							}
						}
					}

					isPointer := false
					if strings.HasPrefix(fieldType, "*") {
						fieldType = strings.Replace(fieldType, "*", "", 1)
						isPointer = true
					}

					emptyValue := ""
					serializeFuncInvocation := ""
					switch fieldType {
					case "bool":
						serializeFuncInvocation = fmt.Sprintf("serializer.SerializeBool(%ss.%s)", getDereferenceSigil(isPointer), fieldName)
						emptyValue = "false"
					case "int", "int8", "int16", "int32", "int64":
						serializeFuncInvocation = fmt.Sprintf("serializer.SerializeInt(int64(%ss.%s))", getDereferenceSigil(isPointer), fieldName)
						emptyValue = "0"
					case "uint", "uint8", "uint16", "uint32", "uint64":
						serializeFuncInvocation = fmt.Sprintf("serializer.SerializeUint(uint64(%ss.%s))", getDereferenceSigil(isPointer), fieldName)
						emptyValue = "0"
					case "float32", "float64":
						serializeFuncInvocation = fmt.Sprintf("serializer.SerializeFloat(float64(%ss.%s))", getDereferenceSigil(isPointer), fieldName)
						emptyValue = "0"
					case "string":
						serializeFuncInvocation = fmt.Sprintf("serializer.SerializeString(%ss.%s)", getDereferenceSigil(isPointer), fieldName)
						emptyValue = `""`
					default:
						panic("TODO")
					}

					buffWriteStmts := []g.Statement{
						g.NewRawStatementf(
							`_, err = buff.WriteString(serializer.SerializePropertyName("%s")+":"+string(%s)+",")`,
							jsonPropertyName,
							serializeFuncInvocation,
						),
						g.NewIf("err != nil", g.NewReturnStatement("nil", "err")),
					}

					nonEmptyValueCondition := fmt.Sprintf("s.%s != %s", fieldName, emptyValue)
					isNilCondition := ""
					if isPointer {
						isNilCondition = fmt.Sprintf("s.%s == nil", fieldName)
						nonEmptyValueCondition = fmt.Sprintf("s.%s != nil && *s.%s != %s", fieldName, fieldName, emptyValue)
					}

					if isOmitEmpty {
						funcStmt = funcStmt.AddStatements(g.NewIf(nonEmptyValueCondition, buffWriteStmts...))
					} else {
						stmt := buffWriteStmts
						if isNilCondition != "" {
							stmt = []g.Statement{g.NewIf(
								isNilCondition,
								g.NewRawStatementf(
									`_, err = buff.WriteString(serializer.SerializePropertyName("%s")+":"+string(serializer.SerializeNull())+",")`,
									jsonPropertyName,
								),
								g.NewIf("err != nil", g.NewReturnStatement("nil", "err")),
							).Else(g.NewElse(buffWriteStmts...))}
						}
						funcStmt = funcStmt.AddStatements(stmt...)
					}
				}

				funcStmt = funcStmt.AddStatements(
					g.NewRawStatement(`bs := buff.Bytes()`),

					// dealing with trailing comma
					g.NewIf(`bs[len(bs)-1] == ','`, g.NewRawStatement("bs[len(bs)-1] = '}'")).
						Else(g.NewElse(g.NewRawStatement("bs = append(bs, '}')"))),

					g.NewReturnStatement("bs, nil"),
				)

				rootStmt = rootStmt.AddStatements(funcStmt)
			}
		}
	}

	code, err := rootStmt.Gofmt("-s").Goimports().Generate(0)
	if err != nil {
		log.Fatal(err)
	}

	err = ioutil.WriteFile(getFilenameToGenerate(args), []byte(code), 0644)
	if err != nil {
		log.Fatal(fmt.Errorf("[error] failed output generated code to a file: %w", err))
	}
}

func getFilenameToGenerate(args []string) string {
	if *output != "" {
		return *output
	}

	var dir string
	if len(args) == 1 && isDirectory(args[0]) {
		dir = args[0]
	} else {
		dir = filepath.Dir(args[0])
	}
	return fmt.Sprintf("%s/%s_gen.go", dir, strcase.ToSnake(*typeName))
}

func isDirectory(name string) bool {
	info, err := os.Stat(name)
	if err != nil {
		log.Fatal(err)
	}
	return info.IsDir()
}

func getDereferenceSigil(isPointer bool) string {
	if isPointer {
		return "*"
	}
	return ""
}
